// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.3
// source: proto/user.proto

package user

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	UserHandler_UserRegister_FullMethodName       = "/proto.userHandler/UserRegister"
	UserHandler_UserLogin_FullMethodName          = "/proto.userHandler/UserLogin"
	UserHandler_UserLogout_FullMethodName         = "/proto.userHandler/UserLogout"
	UserHandler_UserChangePasscode_FullMethodName = "/proto.userHandler/UserChangePasscode"
	UserHandler_UserChangeEmail_FullMethodName    = "/proto.userHandler/UserChangeEmail"
	UserHandler_UserGetInfo_FullMethodName        = "/proto.userHandler/UserGetInfo"
	UserHandler_UserDeactivate_FullMethodName     = "/proto.userHandler/UserDeactivate"
	UserHandler_UserReactivate_FullMethodName     = "/proto.userHandler/UserReactivate"
	UserHandler_UserBlock_FullMethodName          = "/proto.userHandler/UserBlock"
	UserHandler_UserUnblock_FullMethodName        = "/proto.userHandler/UserUnblock"
)

// UserHandlerClient is the client API for UserHandler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserHandlerClient interface {
	UserRegister(ctx context.Context, in *UserRegisterRequest, opts ...grpc.CallOption) (*UserRegisterResponse, error)
	UserLogin(ctx context.Context, in *UserLoginRequest, opts ...grpc.CallOption) (*UserLoginResponse, error)
	UserLogout(ctx context.Context, in *UserLogoutRequest, opts ...grpc.CallOption) (*UserLogoutResponse, error)
	UserChangePasscode(ctx context.Context, in *UserChangePasscodeRequest, opts ...grpc.CallOption) (*UserChangePasscodeResponse, error)
	UserChangeEmail(ctx context.Context, in *UserChangeEmailRequest, opts ...grpc.CallOption) (*UserChangeEmailResponse, error)
	UserGetInfo(ctx context.Context, in *UserGetInfoRequest, opts ...grpc.CallOption) (*UserGetInfoResponse, error)
	UserDeactivate(ctx context.Context, in *UserDeactivateRequest, opts ...grpc.CallOption) (*UserDeactivateResponse, error)
	UserReactivate(ctx context.Context, in *UserReactivateRequest, opts ...grpc.CallOption) (*UserReactivateResponse, error)
	UserBlock(ctx context.Context, in *UserBlockRequest, opts ...grpc.CallOption) (*UserBlockResponse, error)
	UserUnblock(ctx context.Context, in *UserUnblockRequest, opts ...grpc.CallOption) (*UserUnblockResponse, error)
}

type userHandlerClient struct {
	cc grpc.ClientConnInterface
}

func NewUserHandlerClient(cc grpc.ClientConnInterface) UserHandlerClient {
	return &userHandlerClient{cc}
}

func (c *userHandlerClient) UserRegister(ctx context.Context, in *UserRegisterRequest, opts ...grpc.CallOption) (*UserRegisterResponse, error) {
	out := new(UserRegisterResponse)
	err := c.cc.Invoke(ctx, UserHandler_UserRegister_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userHandlerClient) UserLogin(ctx context.Context, in *UserLoginRequest, opts ...grpc.CallOption) (*UserLoginResponse, error) {
	out := new(UserLoginResponse)
	err := c.cc.Invoke(ctx, UserHandler_UserLogin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userHandlerClient) UserLogout(ctx context.Context, in *UserLogoutRequest, opts ...grpc.CallOption) (*UserLogoutResponse, error) {
	out := new(UserLogoutResponse)
	err := c.cc.Invoke(ctx, UserHandler_UserLogout_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userHandlerClient) UserChangePasscode(ctx context.Context, in *UserChangePasscodeRequest, opts ...grpc.CallOption) (*UserChangePasscodeResponse, error) {
	out := new(UserChangePasscodeResponse)
	err := c.cc.Invoke(ctx, UserHandler_UserChangePasscode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userHandlerClient) UserChangeEmail(ctx context.Context, in *UserChangeEmailRequest, opts ...grpc.CallOption) (*UserChangeEmailResponse, error) {
	out := new(UserChangeEmailResponse)
	err := c.cc.Invoke(ctx, UserHandler_UserChangeEmail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userHandlerClient) UserGetInfo(ctx context.Context, in *UserGetInfoRequest, opts ...grpc.CallOption) (*UserGetInfoResponse, error) {
	out := new(UserGetInfoResponse)
	err := c.cc.Invoke(ctx, UserHandler_UserGetInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userHandlerClient) UserDeactivate(ctx context.Context, in *UserDeactivateRequest, opts ...grpc.CallOption) (*UserDeactivateResponse, error) {
	out := new(UserDeactivateResponse)
	err := c.cc.Invoke(ctx, UserHandler_UserDeactivate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userHandlerClient) UserReactivate(ctx context.Context, in *UserReactivateRequest, opts ...grpc.CallOption) (*UserReactivateResponse, error) {
	out := new(UserReactivateResponse)
	err := c.cc.Invoke(ctx, UserHandler_UserReactivate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userHandlerClient) UserBlock(ctx context.Context, in *UserBlockRequest, opts ...grpc.CallOption) (*UserBlockResponse, error) {
	out := new(UserBlockResponse)
	err := c.cc.Invoke(ctx, UserHandler_UserBlock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userHandlerClient) UserUnblock(ctx context.Context, in *UserUnblockRequest, opts ...grpc.CallOption) (*UserUnblockResponse, error) {
	out := new(UserUnblockResponse)
	err := c.cc.Invoke(ctx, UserHandler_UserUnblock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserHandlerServer is the server API for UserHandler service.
// All implementations must embed UnimplementedUserHandlerServer
// for forward compatibility
type UserHandlerServer interface {
	UserRegister(context.Context, *UserRegisterRequest) (*UserRegisterResponse, error)
	UserLogin(context.Context, *UserLoginRequest) (*UserLoginResponse, error)
	UserLogout(context.Context, *UserLogoutRequest) (*UserLogoutResponse, error)
	UserChangePasscode(context.Context, *UserChangePasscodeRequest) (*UserChangePasscodeResponse, error)
	UserChangeEmail(context.Context, *UserChangeEmailRequest) (*UserChangeEmailResponse, error)
	UserGetInfo(context.Context, *UserGetInfoRequest) (*UserGetInfoResponse, error)
	UserDeactivate(context.Context, *UserDeactivateRequest) (*UserDeactivateResponse, error)
	UserReactivate(context.Context, *UserReactivateRequest) (*UserReactivateResponse, error)
	UserBlock(context.Context, *UserBlockRequest) (*UserBlockResponse, error)
	UserUnblock(context.Context, *UserUnblockRequest) (*UserUnblockResponse, error)
	mustEmbedUnimplementedUserHandlerServer()
}

// UnimplementedUserHandlerServer must be embedded to have forward compatible implementations.
type UnimplementedUserHandlerServer struct {
}

func (UnimplementedUserHandlerServer) UserRegister(context.Context, *UserRegisterRequest) (*UserRegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister not implemented")
}
func (UnimplementedUserHandlerServer) UserLogin(context.Context, *UserLoginRequest) (*UserLoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedUserHandlerServer) UserLogout(context.Context, *UserLogoutRequest) (*UserLogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogout not implemented")
}
func (UnimplementedUserHandlerServer) UserChangePasscode(context.Context, *UserChangePasscodeRequest) (*UserChangePasscodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserChangePasscode not implemented")
}
func (UnimplementedUserHandlerServer) UserChangeEmail(context.Context, *UserChangeEmailRequest) (*UserChangeEmailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserChangeEmail not implemented")
}
func (UnimplementedUserHandlerServer) UserGetInfo(context.Context, *UserGetInfoRequest) (*UserGetInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserGetInfo not implemented")
}
func (UnimplementedUserHandlerServer) UserDeactivate(context.Context, *UserDeactivateRequest) (*UserDeactivateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserDeactivate not implemented")
}
func (UnimplementedUserHandlerServer) UserReactivate(context.Context, *UserReactivateRequest) (*UserReactivateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserReactivate not implemented")
}
func (UnimplementedUserHandlerServer) UserBlock(context.Context, *UserBlockRequest) (*UserBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserBlock not implemented")
}
func (UnimplementedUserHandlerServer) UserUnblock(context.Context, *UserUnblockRequest) (*UserUnblockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUnblock not implemented")
}
func (UnimplementedUserHandlerServer) mustEmbedUnimplementedUserHandlerServer() {}

// UnsafeUserHandlerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserHandlerServer will
// result in compilation errors.
type UnsafeUserHandlerServer interface {
	mustEmbedUnimplementedUserHandlerServer()
}

func RegisterUserHandlerServer(s grpc.ServiceRegistrar, srv UserHandlerServer) {
	s.RegisterService(&UserHandler_ServiceDesc, srv)
}

func _UserHandler_UserRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserHandlerServer).UserRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserHandler_UserRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserHandlerServer).UserRegister(ctx, req.(*UserRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserHandler_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserHandlerServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserHandler_UserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserHandlerServer).UserLogin(ctx, req.(*UserLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserHandler_UserLogout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserHandlerServer).UserLogout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserHandler_UserLogout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserHandlerServer).UserLogout(ctx, req.(*UserLogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserHandler_UserChangePasscode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserChangePasscodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserHandlerServer).UserChangePasscode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserHandler_UserChangePasscode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserHandlerServer).UserChangePasscode(ctx, req.(*UserChangePasscodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserHandler_UserChangeEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserChangeEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserHandlerServer).UserChangeEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserHandler_UserChangeEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserHandlerServer).UserChangeEmail(ctx, req.(*UserChangeEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserHandler_UserGetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserGetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserHandlerServer).UserGetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserHandler_UserGetInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserHandlerServer).UserGetInfo(ctx, req.(*UserGetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserHandler_UserDeactivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserDeactivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserHandlerServer).UserDeactivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserHandler_UserDeactivate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserHandlerServer).UserDeactivate(ctx, req.(*UserDeactivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserHandler_UserReactivate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReactivateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserHandlerServer).UserReactivate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserHandler_UserReactivate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserHandlerServer).UserReactivate(ctx, req.(*UserReactivateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserHandler_UserBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserHandlerServer).UserBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserHandler_UserBlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserHandlerServer).UserBlock(ctx, req.(*UserBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserHandler_UserUnblock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUnblockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserHandlerServer).UserUnblock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserHandler_UserUnblock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserHandlerServer).UserUnblock(ctx, req.(*UserUnblockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserHandler_ServiceDesc is the grpc.ServiceDesc for UserHandler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserHandler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.userHandler",
	HandlerType: (*UserHandlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserRegister",
			Handler:    _UserHandler_UserRegister_Handler,
		},
		{
			MethodName: "UserLogin",
			Handler:    _UserHandler_UserLogin_Handler,
		},
		{
			MethodName: "UserLogout",
			Handler:    _UserHandler_UserLogout_Handler,
		},
		{
			MethodName: "UserChangePasscode",
			Handler:    _UserHandler_UserChangePasscode_Handler,
		},
		{
			MethodName: "UserChangeEmail",
			Handler:    _UserHandler_UserChangeEmail_Handler,
		},
		{
			MethodName: "UserGetInfo",
			Handler:    _UserHandler_UserGetInfo_Handler,
		},
		{
			MethodName: "UserDeactivate",
			Handler:    _UserHandler_UserDeactivate_Handler,
		},
		{
			MethodName: "UserReactivate",
			Handler:    _UserHandler_UserReactivate_Handler,
		},
		{
			MethodName: "UserBlock",
			Handler:    _UserHandler_UserBlock_Handler,
		},
		{
			MethodName: "UserUnblock",
			Handler:    _UserHandler_UserUnblock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/user.proto",
}
